---
# 文章的标题
title: "设计模式"
# 文章的时间
date: 2024-04-14T09:32:59+08:00
# 文章是否为草稿状态 草稿状态不会发布到文章列表
draft: false
# 文章描述 在文章列表页展示的内容
description: "文章描述"
# 文章的过期时间  过期后不会发布到文章列表
#expiryDate:  //.ExpiryDate
# 文章的发布时间  未到达发布时间不会发布到文章列表
#publishDate: //.PublishDate
# 上次修改的日期
#lastmod: // .Lastmod
# 作者
author: "OverLookArt"
---

## 设计模式的要素

模式是对特定问题的解决方案。设计模式的核心在于提供了相关问题的解决方案，可以更加简单方便的复用成功的设计和体系结构。设计模式是前人通过开发经验对特定的代码进行设计，总结出来一套解决特定问题的方案，来提高代码的可维护性、可重用性、可理解性、可靠性等。设计模式的4个基本要素为：模式名称、问题、解决方案、效果

## 设计模式分类

* `创建型设计模式`与对象的创建有关，`结构型设计模式`处理类或对象的组合，`行为型设计模式`对类或对象怎样交互和怎样分配职责进行描述

||创建型|机构型|行为型|
|---|---|---|---|
|类| 工场方法模式 | 适配器模式 | 解释器模式  模版方法模式 |
|对象| 抽象工场模式、生成器模式、原型模式、单例模式 | 适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式 | 责任链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式


## 创建型设计模式

主要用于对象的创建

* 创建型设计模式抽象了实例化过程，它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建模型使用继承改变被实例化的类，而一个对象创建模型将实例化委托给另一个对象
* 将对象的创建和对象的使用分离，在使用对象时无需知道对象创建的细节，使设计更加符合单一职责原则，降低了系统的耦合性，且易于扩展，

|创建型设计模式|定义|类型|记忆口诀|
|---|---|---|---|
|抽象工场模式(Abstract Factory)|提供一个创建一系列相关或相互依赖的对象`接口`，无需指定它们具体的类|创建型对象模式|抽象接口|
|生成器模式(Builder)|将一个复杂对象的组件与它的表示`分离`，使得相同的构建过程可以创建不同的表示|属于创建型对象模式|构造分离|
|工程方法模式(Factory Method)|定义一个用于创建对象的接口，让`子类决定实例化`哪一个类，使一个类的实例化延迟到其子类|属于创建型类模式|子类决定实例化|
|原型模式(Prototype)|用`原型实例`指定创建对象的种类，并且通过复制这型原型创建新的对象|属于创建对象模式|原型实例|
|单例模式(Singlgton)|保证一个类`只有一个实例`，并提供一个访问它的全局访问点|属于创建对象模式|只有一个实例|

## 结构型设计模式

主要用于处理类或对象的组合，分为结构型类模式和结构型对象模式，在结构类模式中主要是类的继承和实现，在结构型对象模式中主要是类与对象的关联关系。根据组合重用原则，大部分结构型模式是结构型对象模式

适配器模式可以是结构型类模式，也可以是结构型对象模式，其他均为结构型对象模式

|结构型设计模式|定义|记忆口诀|
|---|---|---|
|适配器模式(Adapter)|将一个类的接口转换成另一种接口，使原本由与接口不兼容而不能一起工作的类可以在一起工作|转换成兼容接口|
|桥接模式(Bridge)|将抽象部分与其实现部分分离，使它们都可以独立变化|抽象与实现分离|
|组合模式(Composite)|将对象组合成树形结构表示部分整体的层次结构，它使得用户对单个对象组合和组合对象的使用具有一致性|树形结构|
|装饰模式(Decorator)|动态的给一个对象添加一些额外的职责|额外的职责|
|外观模式(Facade)|为子系统中的一组接口提供一个一致的界面，它定义了一个高层接口，这个接口使得这一子系统更加容易使用|一致的界面|
|享元模式(Flyweight)|运用共享技术有效的支持大量细粒度的对象|共享|
|代理模式(Proxy)|为其他对象提供一种代理以控制对这个对象的访问|代理|

## 行为型设计模式

主要描述类或对象的交互行为和分配职责

|行为型设计模式|定义|记忆口诀|
|---|---|---|
|责任链模式(Chain of Responsibility)|使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这型对象连成一条链。并沿着这条链传递该请求，直到有一个对象处理它为止|机会连成一条链|
|命令模式(Command)|将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作|参数化|
|解释器模式(Interpreter)|给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子|解释器|
|迭代器模式(Iterator)|提供一种方法顺序访问一个聚合对象的各个元素，且不需要暴露该对象的内部表示|顺序访问|
|中介者模式(Mediator)|用一个中介对象来封装一系列的对象交互，它使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立改变它们之间的交互|中介对象|
|备忘录模式(Memento)|在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态|保存状态|
|观察者模式(Observer)|定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新|自动更新|
|状态模式(State)|允许一个对象在其内部状态改变时改变它的行为|状态改变|
|策略模式(Strategy)|定义一系列的算法，把他们一个个封装起来，并且使它们可以相互替换，它使得算法可以独立于使用它们的客户而变化|算法相互替换|
|模版方法模式(Template Method)|定义一个操作中的算法骨架，而将一线步骤延迟到子类中，它使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤|重新定义算法|
|访问者模式(Visitor)|表示一个作用于某个对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作|新操作|
